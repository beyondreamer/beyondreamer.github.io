<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/post/16107.html</url>
    <content><![CDATA[<p>Welcome to <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvLw==">Hexo<i class="fa fa-external-link-alt"></i></span>! This is your very first post. Check <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv">documentation<i class="fa fa-external-link-alt"></i></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=">troubleshooting<i class="fa fa-external-link-alt"></i></span> or you can ask me on <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==">GitHub<i class="fa fa-external-link-alt"></i></span>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s">Writing<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=">Server<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s">Generating<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s">Deployment<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构笔记（四）队列</title>
    <url>/post/0.html</url>
    <content><![CDATA[<h2 id="队列">队列</h2>
<p><strong>队列</strong>：具有一定操作约束的线性表<br>
数据插入：入队列（AddQ）<br>
数据删除：出队列（DeleteQ）<br>
先来先服务<br>
先进先出：FIFO</p>
<h3 id="队列的抽象数据类型描述">队列的抽象数据类型描述</h3>
<p><strong>类型名称</strong>：队列(Queue)<br>
<strong>数据对象集</strong>：一个有0个或多个元素的有穷线性表。<br>
<strong>操作集</strong>：长度为MaxSize的队列Q，队列元素item</p>
<ol>
<li><code>Queue CreatQueue( int MaxSize )</code>：生成长度为MaxSize的空队列；</li>
<li><code>int IsFullQ( Queue Q, int MaxSize )</code>：判断队列Q是否已满；</li>
<li><code>void AddQ( Queue Q, ElementType item )</code>： 将数据元素item插入队列Q中；</li>
<li><code>int IsEmptyQ( Queue Q )</code>： 判断队列Q是否为空；</li>
<li><code>ElementType DeleteQ( Queue Q )</code>：将队头数据元素从队列中删除并返回</li>
</ol>
<h3 id="队列的顺序存储实现">队列的顺序存储实现</h3>
<p>通常由一个一维数组和一个记录队列头元素位置的变量front，以及一个记录队列尾元素位置的变量rear组成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize <span class="meta-string">&lt;储存数据元素的最大个数&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">ElementType Data[ MaxSize ];</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>入队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">( Queue PtrQ, ElementType item)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">if</span>((PtrQ-&gt;rear+<span class="number">1</span>)%MaxSize == PtrQ-&gt;front )&#123;</span><br><span class="line">         <span class="built_in">printf</span>(“队列满”); </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     PtrQ-&gt;rear = (PtrQ-&gt;rear+<span class="number">1</span>)% MaxSize;</span><br><span class="line">     PtrQ-&gt;Data[PtrQ-&gt;rear] = item;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>出队</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span> <span class="params">( Queue PtrQ )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="keyword">if</span>(PtrQ-&gt;front == PtrQ-&gt;rear)&#123; </span><br><span class="line">         <span class="built_in">printf</span>(“队列空”);</span><br><span class="line">         <span class="keyword">return</span> ERROR;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         PtrQ-&gt;front = (PtrQ-&gt;front+<span class="number">1</span>)% MaxSize;</span><br><span class="line">         <span class="keyword">return</span> PtrQ-&gt;Data[PtrQ-&gt;front];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="队列的链式存储实现">队列的链式存储实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"> ElementType Data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span> <span class="comment">/* 链队列结构 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">rear</span>;</span> <span class="comment">/* 指向队尾结点 */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">front</span>;</span> <span class="comment">/* 指向队头结点 */</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line">Queue PtrQ;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>不带头结点的链式队列出队操作的一个示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">DeleteQ</span> <span class="params">( Queue PtrQ )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">FrontCell</span>;</span> </span><br><span class="line">    ElementType FrontElem;</span><br><span class="line">    <span class="keyword">if</span>(PtrQ-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“队列空”); </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">     &#125;</span><br><span class="line">     FrontCell = PtrQ-&gt;front;</span><br><span class="line">     <span class="keyword">if</span>(PtrQ-&gt;front == PtrQ-&gt;rear)</span><br><span class="line">     <span class="comment">/* 若队列只有一个元素 */</span></span><br><span class="line">     PtrQ-&gt;front = PtrQ-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">     <span class="comment">/* 删除后队列置为空 */</span></span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         PtrQ-&gt;front = PtrQ-&gt;front-&gt;Next;</span><br><span class="line">     FrontElem = FrontCell-&gt;Data;</span><br><span class="line">     <span class="built_in">free</span>( FrontCell ); </span><br><span class="line">     <span class="comment">/* 释放被删除结点空间 */</span></span><br><span class="line">     <span class="keyword">return</span> FrontElem;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（六）二叉树</title>
    <url>/post/0.html</url>
    <content><![CDATA[<h2 id="二叉树的定义及基本特点">二叉树的定义及基本特点</h2>
<h3 id="定义">定义</h3>
<p>二叉树（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n = 0）；或为非空树</p>
<p>对于非空树T：</p>
<ol>
<li>有且仅有一个称之为根的结点</li>
<li>除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。</li>
</ol>
<h3 id="基本特点">基本特点</h3>
<ol>
<li>结点的度小于等于2</li>
<li>有序树：二叉树的子树有<strong>左右顺序</strong>之分</li>
</ol>
<h3 id="二叉树的性质">二叉树的性质</h3>
<ol>
<li>在二叉树的第i层上至多有$2^{i-1}$个结点</li>
<li>深度为k的二叉树至多有$2^k-1$个结点</li>
<li>对于任何一棵二叉树，若2度的结点数有$n_{2}$个，则叶子数$n_{0}$必定为$n_{2}+1$（即$n_{0}=n_{2}+1$）</li>
<li>完全二叉树：深度为k 的，有n个结点的二叉树，当且仅当其每一个结点都与深度为k 的满二叉树中编号从1至n的结点一一对应</li>
<li>满二叉树：一棵深度为k 且有$2k − 1$个结点的二叉树。（特点：每层都“充满”了结点） 满二叉树是完全二叉树的一个特例。</li>
<li>具有n个结点的完全二叉树的深度必为$⌊log2n⌋＋1$</li>
<li>对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为$2i$，其右孩子编号必为$2i＋1$；其双亲的编号必为$\frac {i} {2}$</li>
</ol>
<h3 id="二叉树的抽象数据类型定义">二叉树的抽象数据类型定义</h3>
<p><strong>类型名称</strong>：二叉树<br>
<strong>数据对象集</strong>：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成。<br>
<strong>操作集</strong>：</p>
<ol>
<li><code>Boolean IsEmpty( BinTree BT )</code>： 判别BT是否为空；</li>
<li><code>void Traversal( BinTree BT )</code>：遍历，按某顺序访问每个结点；</li>
<li><code>BinTree CreatBinTree( )</code>：创建一个二叉树。</li>
</ol>
<p>常用的遍历方法有：</p>
<ol>
<li><code>void PreOrderTraversal( BinTree BT )</code>：先序----根、左子树、右子树；</li>
<li><code>void InOrderTraversal( BinTree BT )</code>： 中序—左子树、根、右子树；</li>
<li><code>void PostOrderTraversal( BinTree BT )</code>：后序—左子树、右子树、根</li>
<li><code>void LevelOrderTraversal( BinTree BT )</code>：层次遍历，从上到下、从左到右</li>
</ol>
<h3 id="二叉树的存储结构">二叉树的存储结构</h3>
<ol>
<li>顺序存储</li>
<li>链式存储</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> BinTree Position;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;BinTree Right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在n个结点的二叉链表中，有(n+1)个空指针域</p>
<h3 id="遍历二叉树">遍历二叉树</h3>
<p>DLR—先序遍历，即先根再左再右<br>
LDR—中序遍历，即先左再根再右<br>
LRD—后序遍历，即先左再右再根</p>
<p>若二叉树中各结点的值均不相同，则由二叉树的前序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树，但由前序序列和后序序列却不一定能唯一地确定一棵二叉树。</p>
<ol>
<li>递归版先序中序后序</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归遍历二叉树</span></span><br><span class="line"><span class="comment">//先序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">( BinTree BT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, BT-&gt;Data);</span><br><span class="line">        PreOrderTraversal( BT-&gt;Left );</span><br><span class="line">        PreOrderTraversal( BT-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">( BinTree BT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        InOrderTraversal( BT-&gt;Left );</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal( BT-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">( BinTree BT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        PostOrderTraversal( BT-&gt;Left );</span><br><span class="line">        PostOrderTraversal( BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, BT-&gt;Data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>中序遍历的非递归遍历</p>
<ul>
<li>遇到一个结点，就把它压栈，并去遍历它的左子树；</li>
<li>当左子树遍历结束后，从栈顶弹出这个结点并访问它；</li>
<li>然后按其右指针再去中序遍历该结点的右子树</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归遍历（中序） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">( BinTree BT )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    BinTree T=BT;</span><br><span class="line">    Stack S = CreatStack( MaxSize ); <span class="comment">/*创建并初始化堆栈S*/</span></span><br><span class="line">    <span class="keyword">while</span>( T || !IsEmpty(S) )&#123;</span><br><span class="line">        <span class="keyword">while</span>(T)&#123; <span class="comment">/*一直向左并将沿途结点压入堆栈*/</span></span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            T = Pop(S); <span class="comment">/*结点弹出堆栈*/</span></span><br><span class="line">            <span class="built_in">printf</span>(“%<span class="number">5</span>d”, T-&gt;Data); <span class="comment">/*（访问）打印结点*/</span></span><br><span class="line">            T = T-&gt;Right; <span class="comment">/*转向右子树*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>先序遍历的非递归遍历算法</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraversal</span><span class="params">( BinTree BT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree T BT;</span><br><span class="line">    Stack S = CreatStack( MaxSize ); <span class="comment">/*创建并初始化堆栈S*/</span></span><br><span class="line">    <span class="keyword">while</span>( T || !IsEmpty(S) )&#123;</span><br><span class="line">        <span class="keyword">while</span>(T)&#123; <span class="comment">/*一直向左并将沿途结点压入堆栈*/</span></span><br><span class="line">            Push(S,T);</span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!IsEmpty(S))&#123;</span><br><span class="line">            T = Pop(S); <span class="comment">/*结点弹出堆栈*/</span></span><br><span class="line">            <span class="built_in">printf</span>(“%<span class="number">5</span>d”, T-&gt;Data); <span class="comment">/*（访问）打印结点*/</span></span><br><span class="line">            T = T-&gt;Right; <span class="comment">/*转向右子树*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>层序遍历</li>
</ol>
<ul>
<li>从队列中取出一个元素；</li>
<li>访问该元素所指结点；</li>
<li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span> <span class="params">( BinTree BT )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Queue Q; BinTree T;</span><br><span class="line">    <span class="keyword">if</span>( !BT ) <span class="keyword">return</span>; <span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">    Q = CreatQueue( MaxSize ); <span class="comment">/*创建并初始化队列Q*/</span></span><br><span class="line">    AddQ( Q, BT );</span><br><span class="line">    <span class="keyword">while</span> ( !IsEmptyQ( Q ) ) &#123;</span><br><span class="line">        T = DeleteQ( Q );</span><br><span class="line">        <span class="built_in">printf</span>(“%d\n”, T-&gt;Data); <span class="comment">/*访问取出队列的结点*/</span> </span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Left ) AddQ( Q, T-&gt;Left );</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Right ) AddQ( Q, T-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的建立">二叉树的建立</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立二叉树 (先序）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span> (ch==<span class="string">&#x27;#&#x27;</span>)   T=<span class="literal">NULL</span>;   <span class="comment">//递归结束，建空树</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;  <span class="comment">//生成根结点</span></span><br><span class="line">        CreateBiTree(T-&gt;lchild);  <span class="comment">//递归创建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild); <span class="comment">//递归创建右子树</span></span><br><span class="line">    &#125;         </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="其他应用">其他应用</h3>
<ol>
<li>复制二叉树</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T,BiTree &amp;NewT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        NewT=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        NewT=<span class="keyword">new</span> BiTree;</span><br><span class="line">        NewT-&gt;data=T-&gt;data;</span><br><span class="line">        copy(T-&gt;lchild,NewT-&gt;lchild);</span><br><span class="line">        copy(T-&gt;rchild,NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>二叉树遍历算法的应用</li>
</ol>
<pre><code class="language-c">//计算二叉树叶子节点总数
int LeadCount(BiTree T)&#123;
    if(T==NULL)  //如果是空树返回0
        return 0;
    if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL)
        return 1; //如果是叶子结点返回1
    else 
        return LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);
&#125;

//计算二叉树的深度
int Depth(BiTree T)&#123;
    if(T==NULL)  //如果是空树返回0
        return 0;
    else&#123;
        m=Depth(T-&gt;lchild);
        n=Depth(T-&gt;rchild);
        if(m&gt;n) return m+1;
        else return n+1;
    &#125;
&#125;

//计算二叉树中结点的个数
int NodeCount(BiTree T) &#123;
    if(T==NULL)
        return 0;
    else
        return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（五）树与树的表示</title>
    <url>/post/14197.html</url>
    <content><![CDATA[<h2 id="树的定义">树的定义</h2>
<p>树（Tree）: n（n≥0）个结点构成的有限集合。</p>
<ul>
<li>当n=0时，称为空树；</li>
<li>对于任一棵非空树（n&gt; 0），它具备以下性质：
<ul>
<li>树中有一个称为“根（Root）”的特殊结点，用 r 表示；</li>
<li>其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2，… ，Tm，其中每个集合本身又是一棵树，称为原来树的“子树（SubTree）”</li>
</ul>
</li>
<li>子树是不相交的；</li>
<li>除了根结点外，每个结点有且仅有一个父结点；</li>
<li>一棵N个结点的树有N-1条边。</li>
</ul>
<h3 id="基本术语">基本术语</h3>
<ol>
<li>结点的度（Degree）：结点的子树个数</li>
<li>树的度：树的所有结点中最大的度数</li>
<li>叶结点（Leaf）：度为0的结点</li>
<li>父结点（Parent）：有子树的结点是其子树<br>
的根结点的父结点</li>
<li>子结点（Child）：若A结点是B结点的父结<br>
点，则称B结点是A结点的子结点；子结点也<br>
称孩子结点。</li>
<li>兄弟结点（Sibling）：具有同一父结点的各<br>
结点彼此是兄弟结点。</li>
<li>路径和路径长度：从结点n1到nk的路径为一<br>
个结点序列n1 , n2,… , nk, ni是 ni+1的父结点。路径所包含边的个数为路径的长度。</li>
<li>祖先结点(Ancestor)：沿树根到某一结点路<br>
径上的所有结点都是这个结点的祖先结点。</li>
<li>子孙结点(Descendant)：某一结点的子树<br>
中的所有结点是这个结点的子孙。</li>
<li>结点的层次（Level）：规定根结点在1层，<br>
其它任一结点的层数是其父结点的层数加1。</li>
<li>树的深度（Depth）：树中所有结点中的最<br>
大层次是这棵树的深度。</li>
</ol>
<h3 id="树的实现">树的实现</h3>
<p>儿子兄弟表示法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    PtrToNode FirstChild;</span><br><span class="line">    PtrToNode NextSibiling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（二）线性表</title>
    <url>/post/5904.html</url>
    <content><![CDATA[<h2 id="线性结构">线性结构</h2>
<h3 id="2-1线性表及其表现">2.1线性表及其表现</h3>
<h4 id="什么是线性表？">什么是线性表？</h4>
<p>线性表是由同类型<strong>数据结构</strong>构成<strong>有序序列</strong>的线性结构</p>
<ul>
<li>表中元素个数称为线性表的<strong>长度</strong></li>
<li>线性表没有元素时，称为<strong>空表</strong></li>
<li>表起始位置称<strong>表头</strong>，表结束位置称<strong>表尾</strong></li>
</ul>
<h3 id="2-2线性表的抽象数据类型描述">2.2线性表的抽象数据类型描述</h3>
<p><strong>类型名称</strong>：线性表<br>
<strong>数据对象集</strong>：线性表是n(&gt;=0)个元素构成的有序序列($a_{1},a_{2}…$)<br>
<strong>操作集</strong>：线性表L，整数i表示位置，元素X，线性表的基本操作有：</p>
<ol>
<li><code>List MakeEmpty()</code>：初始化一个空线性表</li>
<li><code>ElementType FindKth(int K,List L)</code>：根据位序K，返回相应元素</li>
<li><code>int Find(ElementType X,List L)</code>：在线性表L中查找X的第一次出现位置</li>
<li><code>void Insert(ElementType X,int i,List L)</code>：在位序i先插入一个新元素X</li>
<li><code>void Delete(int i,List L)</code>:删除指定位序i的元素</li>
<li><code>int Length(List L)</code>：返回线性表L的长度n</li>
</ol>
<h4 id="2-2-1线性表的顺序存储实现">2.2.1线性表的顺序存储实现</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> Last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List PtrL;</span><br></pre></td></tr></table></figure>
<p>主要操作的实现</p>
<ol>
<li>
<p>初始化（建立空的顺序表）</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">MakeEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Ptrl;</span><br><span class="line">    Ptrl = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">    Ptrl-&gt;Last = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> Ptrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(ElementType X,List Ptrl)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=Ptrl-&gt;Last&amp;&amp;Ptrl-&gt;Data[i]!=X)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;Ptrl-&gt;Last)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>插入</p>
<ul>
<li>先移动后插入</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(Ptrl-&gt;Last==MAXSIZE<span class="number">-1</span>)<span class="comment">/*表空间满不能插入*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;表满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;Ptrl-&gt;Last+<span class="number">2</span>)<span class="comment">/*检查位置是否合法*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置不合法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=Ptrl-&gt;Last;j&gt;=i<span class="number">-1</span>;j--)<span class="comment">/*将其倒序移动*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ptrl-&gt;Data[j+<span class="number">1</span>] = Ptrl-&gt;Data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    Ptrl-&gt;Data[i<span class="number">-1</span>]=X;</span><br><span class="line">    Ptrl-&gt;Last++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除</p>
</li>
</ol>
<ul>
<li>
<p>后面的元素依次前移</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;Ptrl-&gt;Last+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不存在该元素&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;=Ptrl-&gt;Last;j++)<span class="comment">/*将其向前移动*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ptrl-&gt;Data[j<span class="number">-1</span>]=Ptrl-&gt;Data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    Ptrl-&gt;Last--;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-2线性表的链式存储实现">2.2.2线性表的链式存储实现</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">L</span>;</span></span><br><span class="line">List Ptrl;</span><br></pre></td></tr></table></figure>
<p>主要操作的实现</p>
<ol>
<li>
<p>求表长</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = Ptrl;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查找</p>
<ul>
<li>按序号查找FindKth</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> K,List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = Ptrl;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;K)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==K)<span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>按值查找Find</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Find</span><span class="params">(ElementType X,List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p = Ptrl;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;Data!=X)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>插入</p>
<ul>
<li>先构造一个新节点，用s指向</li>
<li>再找到链表的第i-1个节点，用p指向</li>
<li>然后修改指针，插入节点（p之后插入新节点是s）</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Insert</span><span class="params">(ElementType X,<span class="keyword">int</span> i,List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)<span class="comment">/*新节点插入在表头*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = Ptrl;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,Ptrl);<span class="comment">/*查找第i-1个节点*/</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;参数出错&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode));</span><br><span class="line">        s-&gt;Data = X;</span><br><span class="line">        s-&gt;Next = p-&gt;Next;<span class="comment">/*新节点插入在第i-1个节点后面*/</span></span><br><span class="line">        p-&gt;Next = s;</span><br><span class="line">        <span class="keyword">return</span> Ptrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除</p>
<ul>
<li>先找到链表的第i-1个节点，用p指向</li>
<li>用s指针指向要被删除的节点（p的下一个节点）</li>
<li>然后修改指针，删除s所指节点</li>
<li>最后释放s所指节点的空间</li>
</ul>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> i,List Ptrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List p,s;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = Ptrl;</span><br><span class="line">        <span class="keyword">if</span>(Ptrl!=<span class="literal">NULL</span>) Ptrl= Ptrl-&gt;Next;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> Ptrl;</span><br><span class="line">    &#125;</span><br><span class="line">    p = FindKth(i<span class="number">-1</span>,Ptrl);</span><br><span class="line">    <span class="keyword">if</span>(p = <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该节点不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;Next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;后一个节点不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        s = p-&gt;Next;</span><br><span class="line">        p-&gt;Next = s-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">        <span class="keyword">return</span> Ptrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="广义表">广义表</h4>
<ul>
<li>广义表是<strong>线性表的推广</strong></li>
<li>对于线性表而言，n个元素都是基本的<strong>单元素</strong></li>
<li>广义表中，这些元素不仅可以是单元素也可以是<strong>另一个广义表</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">GList</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Tag;<span class="comment">/*标志域：0表示节点是单元素，1表示结点是广义表*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span><span class="comment">/*子表指针域Sublist域单元素数据域Data共用存储空间*/</span></span><br><span class="line">        ElementType Data;</span><br><span class="line">        GList SubList;</span><br><span class="line">    &#125;URegion;</span><br><span class="line">    Glist Next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多重链表">多重链表</h4>
<p><strong>多重链表</strong>：链表中的节点啃同时隶属于多个链</p>
<ul>
<li>多重链表中结点的<strong>指针域会有多个</strong></li>
<li>但包含两个指针域的链表并不一定是多重链表，比如<strong>双向链表</strong></li>
</ul>
<p>十字链表</p>
<ul>
<li>只存储矩阵非0元素
<ul>
<li>结点的<strong>数据域</strong>：行坐标Row，列坐标Col，数值Value。</li>
</ul>
</li>
<li>每个结点通过<strong>两个指针域</strong>把行列串起来
<ul>
<li>行指针Right</li>
<li>列指针Down</li>
</ul>
</li>
<li>用一个标识域Tag来区分头结点和非0元素结点</li>
<li>头结点的标识值为&quot;Head&quot;，矩阵非0元素结点的标识值&quot;Term&quot;</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（三）栈</title>
    <url>/post/39226.html</url>
    <content><![CDATA[<h2 id="堆栈">堆栈</h2>
<h3 id="堆栈的抽象数据类型描述">堆栈的抽象数据类型描述</h3>
<ul>
<li>具有一定操作约束的线性表</li>
<li>只在栈顶做插入删除</li>
<li>插入数据：<strong>入栈（push）</strong></li>
<li>删除数据：<strong>出栈（pop）</strong></li>
<li><strong>后入先出</strong>：Last In First Out(LIFO)</li>
</ul>
<p><strong>类型名称</strong>：堆栈<br>
<strong>数据对象集</strong>：一个有0个或多个元素的有穷线性表<br>
<strong>操作集</strong>：长度为Maxsize的堆栈Stack 栈顶元素item</p>
<ol>
<li><code>Stack CreatStack(int Maxsize)</code>:生成空堆栈</li>
<li><code>int IsFull(Stack S,int Maxsize)</code>:判断堆栈是否已满</li>
<li><code>void Push(Stack S,ElementType item)</code>:将元素压入堆栈</li>
<li><code>int isEmpty(Stack S)</code>:判断堆栈是否为空</li>
<li><code>ElementType Pop(Stack S)</code>:删除并返回栈顶元素</li>
</ol>
<h3 id="堆栈的顺序存储的实现">堆栈的顺序存储的实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize <span class="meta-string">&lt;存储数据元素的最大个数&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>入栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack Ptrl,ElementType item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ptrl-&gt;Top==MaxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆栈满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Ptrl-&gt;Data[++(Ptrl-&gt;Top)] = item;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack PtrS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ptrs-&gt;Top==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Ptrs-&gt;Data[(PtrS-&gt;Top)--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="堆栈的链式存储的实现">堆栈的链式存储的实现</h3>
<p>栈的链式储存实际上就是一个单链表，叫做<strong>链栈</strong>，插入和删除操作只能在链栈的栈顶进行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>堆栈的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Stack <span class="title">CreatStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S;</span><br><span class="line">    S = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct SNode));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断栈空</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (S-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>压栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(ElementType item,Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">TmpCell</span>;</span></span><br><span class="line">    TmpCell = (struct SNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Struct SNode));</span><br><span class="line">    TmpCell-&gt;Element = item;</span><br><span class="line">    TmpCell-&gt;Next = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = TmpCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>出栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">(Stack S)</span><span class="comment">//删除并返回栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">FirstCell</span>;</span></span><br><span class="line">    ElementType TopElem;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(S))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        FirstCell = S-&gt;Next;</span><br><span class="line">        S-&gt;Next = FirstCell-&gt;Next;</span><br><span class="line">        TopElem = FirstCell-&gt;Element;</span><br><span class="line">        <span class="built_in">free</span>(FirstCell);</span><br><span class="line">        <span class="keyword">return</span> TopElem</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="应用——后缀表达式">应用——后缀表达式</h3>
<p>中缀表达式：运算符号位于两个运算数之间a+b<em>c-d/e<br>
后缀表达式：运算符号位于两个运算数之后abc</em>+de/-</p>
<h4 id="中缀表达式如何转换为后缀表达式">中缀表达式如何转换为后缀表达式</h4>
<ul>
<li>从头到尾读取<strong>中缀表达式的每个对象</strong>对不同对象按不同的情况处理
<ul>
<li>运算数：直接输出</li>
<li>左括号：压入堆栈</li>
<li>右括号：将<strong>栈顶的运算符弹出并输出</strong>，<strong>直到遇到左括号</strong></li>
<li>运算符
<ul>
<li>若<strong>优先级大于栈顶元素</strong>压栈</li>
<li>若<strong>优先级小于等于栈顶运算符</strong>，将栈顶运算符弹出并输出，再比较新的运算符，直到该运算符大于栈顶运算符优先级</li>
</ul>
</li>
<li>若各对象处理完毕，则把堆栈中存留的<strong>运算符一并输出</strong></li>
</ul>
</li>
</ul>
<h4 id="其他">其他</h4>
<p>函数调用及递归实现<br>
深度优先搜索<br>
回溯算法</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>线性结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（七）二叉搜索树</title>
    <url>/post/35884.html</url>
    <content><![CDATA[<h2 id="二叉搜索树">二叉搜索树</h2>
<p>对于树中的每个节点X，它的左子树的所有关键字值小于X的关键字值，右子树中的所有关键字值大于X的关键字值<br>
平均深度 $O(logn)$</p>
<ol>
<li>
<p>MakeEmpty 二叉树的初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">SearchTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(Elementtype X,SearctTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(Elementtype X,SearctTree T)</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(Elementtype X,SearctTree T)</span></span>;</span><br><span class="line"><span class="function">ElementType <span class="title">Retrieve</span><span class="params">(Position P)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Element;</span><br><span class="line">    SearchTree Left;</span><br><span class="line">    SearchTree Right;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MakeEmpty(T-&gt;Left);</span><br><span class="line">        MakeEmpty(T-&gt;Left);</span><br><span class="line">        <span class="built_in">free</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>树形结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构笔记（一）数据结构概念</title>
    <url>/post/48857.html</url>
    <content><![CDATA[<h2 id="1基本概念">1基本概念</h2>
<h3 id="1-1数据结构">1.1数据结构</h3>
<ul>
<li>解决问题方法的效率，跟数据的组织方式有关。</li>
</ul>
<h4 id="1-1-2关于空间使用">1.1.2关于空间使用</h4>
<ul>
<li>解决问题方法的效率，跟空间的利用效率有关。</li>
</ul>
<h4 id="1-1-3关于算法效率">1.1.3关于算法效率</h4>
<ul>
<li>clock():捕捉从程序运行开始到clock()被调用是所耗费的时间。这个时间单位是clock tick，即“时钟打点”。</li>
<li>常数CLK_TCK:机器时钟每秒所走的时钟打点数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> start, stop;</span><br><span class="line"><span class="comment">/* clock_t是clock()函数返回的变量类型*/</span></span><br><span class="line"><span class="keyword">double</span> duration;</span><br><span class="line"><span class="comment">/* 记录被测函数运行时间，以秒为单位*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">/* 不在测试范围内的准备工作写在clock()调用之前*/</span></span><br><span class="line">    start = clock();    <span class="comment">/*开始计时*/</span></span><br><span class="line">    MyFunction();   <span class="comment">/* 被测函数加在这里*/</span></span><br><span class="line">    stop = clock;   <span class="comment">/* 停止计时*/</span></span><br><span class="line">    duration = ((<span class="keyword">double</span>)(stop - start))/CLK_TCK;</span><br><span class="line">    <span class="comment">/* 其他不在测试范围的处理写在后面*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>注意：如果一个函数跑的太快，无法被测，让被测函数<strong>重复运行</strong>充分多次，使得测出的总的时钟打点间隔充分长，最后计算被测函数<strong>平均每场</strong>运行的时间即可！</p>
</li>
<li>
<p>解决问题方法的效率，跟算法的巧妙程度有关。</p>
</li>
</ul>
<h4 id="1-1-3抽象数据类型">1.1.3抽象数据类型</h4>
<h5 id="什么是数据结构">什么是数据结构</h5>
<ul>
<li><strong>数据对象</strong>在计算机中的组织方式
<ul>
<li>逻辑结构（线性结构、树形结构、图的结构）</li>
<li>物理存储结构</li>
</ul>
</li>
<li>数据对象必定与一系列加在其上的<strong>操作</strong>相关联</li>
<li>完成这些操作所用的方法就是<strong>算法</strong></li>
</ul>
<h5 id="抽象数据类型">抽象数据类型</h5>
<ul>
<li>数据类型
<ul>
<li>数据对象集</li>
<li>数据集合相关联的操作集</li>
</ul>
</li>
<li>抽象：描述数据类型的方法不依赖于具体实现
<ul>
<li>与存放数据的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言结构无关</li>
</ul>
</li>
</ul>
<p>只与描述对象集合相关操作集“<strong>是什么</strong>”，并不涉及到“<strong>如何做到</strong>”的问题</p>
<p>例：</p>
<p><strong>类型名称</strong>：矩阵（Matrix）</p>
<p><strong>数据对象集</strong>：一个$M*N$的矩阵…</p>
<p><strong>操作集</strong>：对于任意矩阵A、B、C、D</p>
<ul>
<li>操作函数及说明…</li>
</ul>
<h3 id="1-2算法的定义">1.2算法的定义</h3>
<ul>
<li>算法
<ul>
<li>一个有限指令集</li>
<li>接受一些输入</li>
<li>产生输出</li>
<li>一定在有限步骤之后终止</li>
<li>每一条指令必须
<ul>
<li>有充分明确的目标，不可以有歧义</li>
<li>计算机能处理的范围之内</li>
<li>描述应不依赖于任何一种计算机语言以及具体实现手段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-2什么是好的算法">1.2.2什么是好的算法</h4>
<ul>
<li>
<p><strong>空间复杂度$S(n)$</strong>——根据算法写成的程序在执行时<strong>占用存储单元的长度</strong>。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致使用的内存超限，造成程序非正常中断。</p>
</li>
<li>
<p><strong>时间复杂度$T(n)$</strong>——根据算法写成的程序在执行时<strong>耗费时间的长度</strong>。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</p>
</li>
<li>
<p>在分析一般算法的效率时，我们经常关注下面两种复杂度</p>
<ul>
<li>最坏情况复杂度$T_{worst}(n)$</li>
<li>平均最坏复杂度$T_{avg}(n)$<br>
$$T_{avg}(n)\leq T_{worst}(n)$$</li>
</ul>
</li>
</ul>
<h4 id="1-2-3复杂度的渐进表示法">1.2.3复杂度的渐进表示法</h4>
<ol>
<li>
<p>$T(n)=O(f(n))$表示存在常数$C&gt;0,n_{0}&gt;0$使得当$n&gt;=n_{0}$时有$T(n)\leq C*f(n)$</p>
</li>
<li>
<p>$T(n)=O(g(n))$表示存在常数$C&gt;0,n_{0}&gt;0$使得当$n&gt;=n_{0}$时有$T(n)\leq C*g(n)$</p>
</li>
<li>
<p>若两段算法分别有复杂度$T_{1}(n)=O(f_{1}(n))$和$T_{2}(n)=O(f_{2}(n)$则</p>
<ul>
<li>$T_{1}(n)+T_{2}(n)=max(O(f_{1}(n)),O(f_{2}(n)))$</li>
<li>$T_{1}(n)*T_{2}(n)=O(f_{1}(n)*f_{2}(n))$</li>
</ul>
</li>
</ol>
<h4 id="1-3-1最大连续子列和">1.3.1最大连续子列和</h4>
<p>给定N个整数的序列{$A_{1},A_{2},A_{3}…A_{N}$},求函数$f(i,j) = max(0 , \sum_{k=i}^j A_{k} )$</p>
<p>$T(n)=O(n^2)$算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ThisSum, MaxSum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)<span class="comment">/*i是子列的左端位置*/</span></span><br><span class="line">  &#123;</span><br><span class="line">    ThisSum = <span class="number">0</span>;<span class="comment">/*ThisSum是从A[i]到A[j]的子列和*/</span></span><br><span class="line">    <span class="keyword">for</span>(j = i; j &lt; N; j++)<span class="comment">/*j是子列右端位置*/</span></span><br><span class="line">    &#123;</span><br><span class="line">      ThisSum+=A[j];</span><br><span class="line">      <span class="comment">/*对于相同的i不同的j只要在j-1次循环的基础上累加1即可*/</span></span><br><span class="line">      <span class="keyword">if</span>(ThisSum &gt; MaxSum)<span class="comment">/*如果得到的子列和更大则更新结果*/</span></span><br><span class="line">        MaxSum = ThisSum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分治算法</p>
<p>$T(n)=O(n*log(n))$</p>
<p>在线处理</p>
<p>$T(n)=O(n)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum4</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ThisSum,MaxSum;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  ThisSum = MaxSum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    ThisSum+=A[i];</span><br><span class="line">    <span class="keyword">if</span>(ThisSum&gt;MaxSum)</span><br><span class="line">      MaxSum = ThisSum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum&lt;<span class="number">0</span>;)</span><br><span class="line">      ThisSum=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title>未完成计划</title>
    <url>/post/20301.html</url>
    <content><![CDATA[<ol>
<li>平衡二叉树</li>
<li>伸展树</li>
<li>B树、B+树</li>
<li>优先队列（堆）、d堆</li>
<li>左偏堆、斜堆</li>
<li>二项队列、斐波那契堆</li>
<li>图论概念和拓扑排序</li>
<li>最短路</li>
<li>最小生成树</li>
<li>并查集+路径压缩</li>
<li>散列表</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java学习笔记（一）语言概述</title>
    <url>/post/23193.html</url>
    <content><![CDATA[<h2 id="Java语言概述">Java语言概述</h2>
<ul>
<li>Java语言的概述一级Java语言的发展史</li>
</ul>
<ol>
<li>JDK：Java开发工具箱，（做Java开发必须安装的，这是最根本的一个环境）不是集成开发环境，JDK中是Java最核心的库</li>
<li>J2SE：标准版（基础，要学Java，必须先学SE。基础语法＋基础库）</li>
<li>J2EE：企业版（专门为企业开发软件，为企业提供解决方案，例如OA办公系统）</li>
<li>J2ME：微型版（专门为微型设备做嵌入式开发。）</li>
</ol>
<ul>
<li>Java诞生十周年改名JavaSE JavaEE JavaME</li>
</ul>
<h3 id="Java语言特性">Java语言特性</h3>
<h4 id="简单性">简单性</h4>
<ul>
<li>Java中真正操作内存的：JVM（Java虚拟机）</li>
</ul>
<p>对于C或C++来说，程序员可以直接通过指针来操作内存，而Java虚拟机执行过程中再去操作内存。</p>
<p>Java语言底层是C++所以说jvm是使用C++语言写好的一个虚拟的电脑</p>
<p>Java语言屏蔽了指针概念，程序员不能直接操作指针，或者说程序员不能直接操作内存 ，这种方式也有缺点</p>
<ul>
<li>优点：不容易导致内存泄漏，简单</li>
<li>缺点：效率问题，包括驾驭感都比较差</li>
</ul>
<h3 id="Java是堪称完全面向对象的">Java是堪称完全面向对象的</h3>
<ul>
<li>采用面向对象的方式，可以让复杂问题简单化</li>
</ul>
<h3 id="健壮性">健壮性</h3>
<ul>
<li>
<p>自动垃圾回收机制（gc机制）</p>
<p>相对于C语言来说，Java更健壮，不易导致内存泄漏。JVM负责调度gc机制，程序员不需要干涉。</p>
</li>
</ul>
<h3 id="Java完美支持多线程开发">Java完美支持多线程开发</h3>
<h3 id="可移植性-跨平台">可移植性/跨平台</h3>
<ul>
<li>
<p>Java语言只要编写一次，可以做到到处运行</p>
<p>JVM这种机制实现了跨平台，</p>
</li>
<li>
<p>优点，一次编写到处运行</p>
</li>
<li>
<p>缺点：麻烦，对于运行Java程序来说，必须先安装一个JVM</p>
</li>
</ul>
<h4 id="JDK-JRE-JVM三者之间的关系？">JDK,JRE,JVM三者之间的关系？</h4>
<ul>
<li>
<p>JDK：Java开发工具箱</p>
</li>
<li>
<p>JRE：Java运行环境</p>
</li>
<li>
<p>JVM：Java虚拟机</p>
<p>JDK包括JRE，JRE包括JVM<br>
JVM是不可以独立安装的</p>
</li>
</ul>
<h4 id="对Java的加装与执行的理解（理论比较重要）">对Java的加装与执行的理解（理论比较重要）</h4>
<ul>
<li>Java程序从编写到最终运行经历了哪些过程？？</li>
</ul>
<p>Java程序非常重要的两个阶段</p>
<ul>
<li>编译阶段</li>
<li>运行阶段</li>
</ul>
<p>注意：Java程序员直接编写的Java代码（普通文本）是无法执行被JVM识别的。Java程序员编写的Java代码这种普通文本必须经过一个编译，蒋政普通文本代码变成字节码<br>
JVM能识别字节码，Java代码这种普通文本变成字节码的过程被称为编译</p>
<ol>
<li>
<p>编译阶段和运行阶段可以再不同的操作系统上完成吗？<br>
可以</p>
</li>
<li>
<p>Java源代码一旦编译之后，源代码可以删除吗？只留下字节码可以执行吗？<br>
可以，但是最好不要删除源代码，可以重新打开进行修改。</p>
</li>
<li>
<p>放源代码的文件扩展名必须是 .java<br>
编译生成的字节码文件扩展名是 .class</p>
</li>
<li>
<p>字节码文件是二进制文件吗？<br>
字节码文件不是二进制文件，如果是二进制的话，就不需要JVM，因为操作系统可以直接执行二进制了</p>
</li>
<li>
<p>另外需要注意的是，<br>
一个Java源文件可以编译生成多个最终运行的class文件</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java语言概述</tag>
        <tag>Java特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（七）继承</title>
    <url>/post/48660.html</url>
    <content><![CDATA[<h2 id="继承">继承</h2>
<ol>
<li>使用继承机制来解决代码复用问题</li>
<li>子类extends父类
<ol>
<li>基本作用：子类继承父类</li>
<li>主要作用：有了方法覆盖和多态机制</li>
</ol>
</li>
</ol>
<h3 id="一．继承的相关特性">一．继承的相关特性</h3>
<ol>
<li>b类继承a类，则称a类为超类、父类（superclass）、基类；b类则称为子类（subclass）</li>
<li>Java不支持多继承，c++支持多继承，体现Java简单性（c++更接近现实一点，同时继承两方特点）</li>
<li>Java可以产生间接继承的结果<br>
（1）z直接继承y，间接继承x；</li>
<li>Java中规定，子类继承父类，除构造方法不能被继承外，其他都可以继承，但是私有的属性无法在子类中直接访问（可以间接访问）</li>
<li>Java中的类没有显示继承任何类，则默认继承object类（Java中提供的根类），也就是说，一个对象与生俱来就具有object类中的所有特性</li>
<li>继承也存在一些缺点，类继承后导致两个类耦合度非常高，父类改变子类也随之改变</li>
</ol>
<h3 id="二．什么时候使用继承">二．什么时候使用继承</h3>
<ol>
<li>Is a 能够描述的都可以使用继承</li>
<li>任何一个类没有显示继承任何类，默认继承object类
<ol>
<li>String[] args</li>
<li>System.out.println()
<ul>
<li>System是一个类名，.out后面没()，说明out是变量名（静态变量）</li>
</ul>
</li>
<li>多看JDK源代码（lib.src.zip）</li>
</ol>
</li>
</ol>
<h3 id="三．Object类中的方法">三．Object类中的方法</h3>
<ol>
<li>当源码当中一个方法以;结尾，并且修饰符列表中有native关键字，表示调用c++写的dll程序（dll动态链接库文件）</li>
<li>toString()（实例方法）输出类名和对象在内存堆中的内存地址（内存地址经过哈希算法得出的十六进制的数字）</li>
</ol>
<h3 id="四．方法覆盖">四．方法覆盖</h3>
<ol>
<li>子类对父类方法重新编写override，overwrite</li>
<li>什么时候方法重载
<ol>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同（个数，顺序，类型不同）</li>
</ol>
</li>
<li>当子类对父类继承过来的方法进行方法覆盖之后，子类只执行覆盖之后的方法</li>
<li>怎么构成方法覆盖
<ol>
<li>两个类必须有继承关系</li>
<li>重写之后的方法和之前的方法具有
<ol>
<li>相同的返回值类型</li>
<li>相同的方法名</li>
<li>相同的形式参数列表</li>
</ol>
</li>
<li>访问权限不能更低，可以更高</li>
<li>重写之后的方法，不能比之前的方法抛出更多异常，可以更少</li>
</ol>
</li>
<li>注意事项（有关多态）
<ol>
<li>方法覆盖只针对方法，和属性无关</li>
<li>私有方法，构造方法，不能被覆盖，</li>
<li>只针对实例方法，静态方法覆盖没有意义</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java继承</tag>
        <tag>Java方法覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（三）基本概念</title>
    <url>/post/5391.html</url>
    <content><![CDATA[<h2 id="一、JVM虚拟机">一、JVM虚拟机</h2>
<ol>
<li>栈<br>
在方法被调用的时候，该方法需要的内存空间在栈中分配</li>
<li>堆<br>
凡是通过new运算符创建的对象，储存在堆内存中</li>
<li>方法区<br>
类加载器classloader，将xxx.class字节码文件装载到JVM的时候<br>
会将字节码文件装载到方法区中，方法区中存放代码片段</li>
</ol>
<h2 id="二、内存栈">二、内存栈</h2>
<ul>
<li>栈数据结构stack</li>
</ul>
<ol>
<li>Java语言把常用的数据结构已经都写好了</li>
<li>进栈入栈push</li>
<li>出栈pop</li>
<li>栈帧永远指向栈顶部的元素</li>
<li>数据结构特点：先进后出</li>
<li>注意处于栈顶部的元素最具活跃权</li>
</ol>
<h2 id="三、方法执行时内存变化">三、方法执行时内存变化</h2>
<ol>
<li>方法不调用是不会在栈中分配空间的</li>
<li>方法只有在调用的时候会分配空间，并且调用就是压栈</li>
<li>方法结束后该方法需要的空间就会释放，发生弹栈</li>
</ol>
<h2 id="四、方法重载">四、方法重载</h2>
<ol>
<li>Java怎么进行方法区分
<ul>
<li>Java编译器通过方法名进行区分</li>
<li>Java语言中允许方法名相同的情况出现，可以通过参数类型区分</li>
</ul>
</li>
<li>什么时候发生方法重载
<ul>
<li>在同一个类中</li>
<li>方法名相同</li>
<li>参数列表不同（个数、类型、顺序）</li>
</ul>
</li>
</ol>
<h2 id="五、递归算法">五、递归算法</h2>
<ol>
<li>方法递归，方法自己调用自己</li>
<li>递归必须要有结束条件<br>
递归有合法结束条件，有时候也会出现栈内存溢出错误，因为递归太深一直压栈</li>
<li>实际开发中不建议轻易使用递归，能用for，while代替，尽量使用循环代替，循环效率高，调用内存少，少数情况不递归无法实现</li>
<li>出现栈内存溢出
<ol>
<li>先检查递归结束条件对不对</li>
<li>手动调整JVM栈内存初始化大小</li>
<li>继续扩大栈内存大小Java -x</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java基本概念</tag>
        <tag>JVM虚拟机</tag>
        <tag>内存栈</tag>
        <tag>方法重载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（二）基础语法</title>
    <url>/post/55918.html</url>
    <content><![CDATA[<h2 id="一、注释">一、注释</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*3.注释文档</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="二、引入类">二、引入类</h2>
<ul>
<li>在Java中任何有效的代码必须写到类体中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[ ]args)</span></span>&#123;</span><br><span class="line">   System.<span class="function">out <span class="title">printlin</span><span class="params">(“Test1”)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>一个Java文件可以定义多个class文件</li>
<li>public的类不是必须的，可以没有</li>
<li>在源文件中只要有一个class的定义，那么必然会对应生成一个class文件</li>
<li>public的类可以没有，但是如果有，类名必须跟源文件的文件名一致</li>
<li>public的类有且仅能有一个</li>
<li>每个类可以有一个入口，想从哪个类进去加载哪个类</li>
</ol>
<h2 id="三、标识符">三、标识符</h2>
<h3 id="标识符命名规则">标识符命名规则</h3>
<h4 id="标识符必须遵守以下规则">标识符必须遵守以下规则</h4>
<ol>
<li>标识符由26个英文字符大小写（a~~Z）、数字(0~9)、下划线(_)和美元符号($)组成。</li>
<li>不能以数字开头，不能是关键字</li>
<li>严格区分大小写</li>
<li>标识符的可以为任意长度</li>
</ol>
<p>注意：由于Java严格区分大小写，ITCAST 和itcast是完全不同的标识符</p>
<h4 id="Java中的标识符命名规范">Java中的标识符命名规范</h4>
<ol>
<li>包名<br>
多个单词组成时所有字母小写</li>
<li>类名和接口<br>
多个单词组成时所有单词的首字母大写</li>
<li>变量名和函数名<br>
多个单词组成时第一个单词首字母小写，其他单词首字母大写</li>
<li>常量名<br>
多个单词组成时，字母全部大写，多个单词之间使用_分隔</li>
</ol>
<h2 id="四、变量">四、变量</h2>
<ol>
<li>方法体当中的变量，局部变量</li>
<li>方法体外类体内声明的变量， 成员变量</li>
</ol>
<h2 id="五、基本数据类型">五、基本数据类型</h2>
<p>类型转换的优先级<br>
byte &lt; short(char) &lt; int &lt; long &lt; float &lt; double</p>
<p>注意：</p>
<ul>
<li>byte short char 类型混合运算先转换成int类型再进行运算</li>
<li>boolean类型不能参与类型转换</li>
<li>Java没有任何无符号(unsigned)形式的int、long、short、byte</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zifuchuanpinjie</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;110&quot;</span>+<span class="number">300</span>);</span><br><span class="line">      <span class="comment">//字符串变为”110300”</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyInput</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="comment">//创建一个键盘扫描器对象</span></span><br><span class="line">      java.util.Scanner s = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">      <span class="keyword">int</span> user = s.nextInt();</span><br><span class="line">      <span class="keyword">int</span> ssr = s.nextInt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于表示溢出和出错情况的三个特殊浮点数值</p>
<ul>
<li>正无穷大(Double.POSITIVE_INFINITY)</li>
<li>负无穷大(Double.NEGATIVE_INFINITY)</li>
<li>非数(Double.NaN)
<ul>
<li>
<p>不能如下检测一个特定值是否等于Double.NaN<br>
<code>if(x==Double.NaN)//is never true</code></p>
</li>
<li>
<p>所有非数值的值都认为是不同的,可以用以下方法判断<br>
<code>if(Double.isNaN(x))//check weather x is not a number</code></p>
</li>
</ul>
</li>
</ul>
<p>BigInteger类 大数<br>
BigDecimal类 大实数</p>
<h2 id="六、数组">六、数组</h2>
<ol>
<li><code>int a = new int[10];</code></li>
</ol>
<h2 id="七、方法">七、方法</h2>
<ol>
<li>
<p>[Public static]修饰符列表+返回值类型+方法名+形式参数列表</p>
</li>
<li>
<p>形式参数 每一个都是局部变量，方法结束后内存释放</p>
</li>
<li>
<p>怎么调用方法？<br>
类名.方法名(实际参数列表);<br>
实参和形参的类型和个数必须一一对应</p>
</li>
<li>
<p>方法有返回值可以选择不要，没有意义</p>
</li>
<li>
<p>实参与形参类型不一样，自动类型转换</p>
</li>
<li>
<p>跨类调用，需要有类名，同一个类下面类名可以省略</p>
</li>
<li>
<p>三目运算符有时候可以让代码很简练</p>
</li>
</ol>
<h2 id="八、for-each循环">八、for each循环</h2>
<p><code>for(variable : collection) statement</code><br>
定义一个变量用于暂存集合中的每一个元素，并执行相应的语句</p>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java基本概念</tag>
        <tag>注释</tag>
        <tag>类</tag>
        <tag>标识符</tag>
        <tag>变量</tag>
        <tag>基本数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（八）多态</title>
    <url>/post/23987.html</url>
    <content><![CDATA[<h2 id="多态">多态</h2>
<h3 id="一．多态的基础语法">一．多态的基础语法</h3>
<ol>
<li>Java中允许（向上转型子转父（类似自动类型转换））和（向下转型父转子（类似强制类型转换加转换符））{必须具有继承关系}</li>
<li>编译阶段只知道引用的数据类型，静态绑定成功</li>
<li>运行阶段，动态绑定，动态执行</li>
<li>多态表示多种形态，编译阶段一种（绑定父类方法），运行阶段一种（绑定子类方法）</li>
<li>什么时候使用向下转型（子类特有方法）</li>
<li>向上转型 子到父 自动类型转换 animal a = new cat();</li>
<li>向下转型 父到子 强制类型转换 cat c = (cat)a;
<ol>
<li>Java.lang.NullPointException:空指针异常</li>
<li>Java.lang.ClassCastException:类型转换异常</li>
</ol>
</li>
</ol>
<h3 id="二．Instanceof-运算符">二．Instanceof 运算符</h3>
<ol>
<li>Instanceof运算符可以在运行阶段动态判断引用指向的对象的类型</li>
<li>语法结构
<ol>
<li>(引用 instanceof 类型)</li>
<li>运算结果只能是true/false</li>
</ol>
</li>
</ol>
<h3 id="三．多态在开发中的应用">三．多态在开发中的应用</h3>
<h3 id="四．软件开发原则">四．软件开发原则</h3>
<ol>
<li>开闭原则
<ol>
<li>对扩展开放，</li>
<li>对修改关闭，</li>
</ol>
</li>
</ol>
<h3 id="五．静态方法不存在覆盖">五．静态方法不存在覆盖</h3>
<ol>
<li>多态和对象有关</li>
<li>静态方法不需要对象</li>
</ol>
<h3 id="六．私有方法不能覆盖">六．私有方法不能覆盖</h3>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java多态</tag>
        <tag>Java Instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（六）关键字static、this、super</title>
    <url>/post/6688.html</url>
    <content><![CDATA[<h2 id="Static">Static</h2>
<ol>
<li>Static意为静态</li>
<li>所有static关键字修饰的都是类相关的，类级别的</li>
<li>所有static修饰的都是采用类名.的方式访问</li>
<li>Static修饰的变量：静态变量</li>
<li>Static修饰的方法：静态方法</li>
<li>实例相关的，都是对象相关的，引用.的方式访问，需要先new对象（可能空指针异常）</li>
<li>静态相关的，都是类相关的，类名.的方式访问，不需要new对象</li>
</ol>
<h3 id="一．变量的分类">一．变量的分类</h3>
<ol>
<li>根据声明的位置进行划分
<ol>
<li>在方法体中声明的变量：局部变量</li>
<li>在方法体外声明的变量：成员变量</li>
</ol>
<ul>
<li>实例变量 无static</li>
<li>静态变量 有static</li>
<li>实例方法 无static</li>
<li>静态方法 有static</li>
</ul>
</li>
</ol>
<h3 id="二．什么时候声明实例变量，什么时候声明静态变量">二．什么时候声明实例变量，什么时候声明静态变量</h3>
<ol>
<li>静态变量在类加载时初始化分配好空间，不需要new对象</li>
<li>静态变量储存在方法区</li>
<li>所有对象的某个属性值都是一样的，不建议定义为实例变量（对象级别），建议定义为静态变量（类级别）</li>
</ol>
<h3 id="三．什么时候定义实例方法，什么时候定义静态方法">三．什么时候定义实例方法，什么时候定义静态方法</h3>
<ol>
<li>当这个方法体当中，直接访问了实例变量，这个方法一定是实例方法。</li>
<li>工具类当中的方法，一般都是静态的。</li>
</ol>
<h3 id="四．静态代码块">四．静态代码块</h3>
<ol>
<li>Static{<br>
静态代码块；<br>
}</li>
<li>Static静态代码块什么时候执行呢？
<ol>
<li>类加载时执行，并且只执行一次</li>
<li>静态代码块，在main方法之前执行，自上而下的顺序执行</li>
</ol>
</li>
<li>静态代码块作用
<ol>
<li>不常用（不是吗，每个类都要写）</li>
<li>提供一个类加载的时间点（例如日志信息）</li>
</ol>
</li>
</ol>
<h3 id="五．实例代码块">五．实例代码块</h3>
<ol>
<li>{<br>
}</li>
<li>实例语句块执行时间
<ol>
<li>实例语句块在构造方法执行之前执行</li>
<li>提供了构造方法之前的特殊时机</li>
</ol>
</li>
</ol>
<h2 id="This">This</h2>
<ol>
<li>关键字this</li>
<li>一个对象是一个this，this是一个变量，一个引用，this保存当前对象的内存地址，指向自身，this代表当前对象</li>
<li>This只能使用于在实例方法中，谁调用实例方法，谁就是this</li>
<li>This大部分情况下可以省略，区分实例变量和局部变量时不能省略this</li>
<li>为什么this不能使用于静态方法？（静态方法不需要对象）</li>
<li>This也可以用在构造方法中，还可以用在构造方法中
<ol>
<li>通过当前的构造方法去调用另一个本类的构造方法</li>
<li>This(实际参数);</li>
<li>This语句必须是首行</li>
</ol>
</li>
</ol>
<h2 id="super关键字">super关键字</h2>
<ol>
<li>super与this</li>
<li>super(实参)的作用是初始化当前对象的父类型特征，并不是创建新对象，实际上新对象只创建了一个。</li>
<li>this
<ol>
<li>能出现在实例方法和构造方法中</li>
<li>This.和this()</li>
<li>this不能使用在静态方法中</li>
<li>This.大部分情况下可以省略，区分局部变量和实例变量时不能省略</li>
<li>This()只能出现在构造方法第一行，通当前的构造方法中去调用“本类”其他的构造方法，目的是代码复用</li>
</ol>
</li>
<li>Super
<ol>
<li>能出现在实例方法和构造方法中</li>
<li>super.和super()</li>
<li>Super不能使用在静态方法中</li>
<li>super.大部分情况下可以省略，时不能省略</li>
<li>Super()只能出现在构造方法第一行，通当前的构造方法中去调用“父类”其他的构造方法，目的是创建，子类对象的时候，先初始化父类特征</li>
<li>Super()表示通过子类的构造方法调用父类的构造方法</li>
</ol>
</li>
</ol>
<h3 id="一．Super语法">一．Super语法</h3>
<ol>
<li>当一个构造方法第一行
<ol>
<li>既没有this()又没有super()的话，默认会有一个super()；</li>
<li>表示通过当前子类的构造方法调用父类的无参数构造方法</li>
<li>所以必须保证父类的无参数构造方法存在</li>
</ol>
</li>
<li>子类构造方法执行时必然调用父类构造方法</li>
<li>注意：this()和super()不能共存，它们只能出现在构造方法第一行</li>
<li>在Java中不管是new什么对象，最后object类的无参数构造函数一定会执行（object类的无参构造方法处于栈顶部）</li>
<li>如果父类和子类有同名属性，子类想访问父类属性需要加super()</li>
<li>super不能单独用必须加&quot;.&quot;，super不是引用，不保存地址，不指向任何对象，只代表当前对象内部的那一块父类特征</li>
<li>super.属性名【访问父类的属性】</li>
<li>super.方法名(实参)【访问父类的方法】</li>
<li>super(实参)【调用父类构造方法】</li>
</ol>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java关键字</tag>
        <tag>static</tag>
        <tag>this</tag>
        <tag>super</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（五）构造方法和封装</title>
    <url>/post/35965.html</url>
    <content><![CDATA[<h2 id="一．构造方法constructor">一．构造方法constructor</h2>
<h3 id="1．什么是构造方法">1．什么是构造方法</h3>
<ol>
<li>
<p>构造方法也是一个特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化，换句话来说，构造方法是用来创建对象，并同时给对象的属性赋值</p>
</li>
<li>
<p>语法结构</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 构造方法名 (形式参数列表)&#123;</span><br><span class="line">    构造方法体</span><br><span class="line">    通常在构造方法体中给属性赋值，完成属性的初始化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>修饰符列表public</li>
<li>构造方法名必须和类名一致</li>
<li>构造方法不需要指定返回值类型</li>
</ul>
</li>
<li>
<p>调用构造方法</p>
</li>
</ol>
<p><code>New 构造方法名(实际参数列表)</code></p>
<ul>
<li>当一个类中手动的提供了构造方法，那么系统将不再提供无参数的构造方法（建议把无参数构造方法写出来）</li>
<li>当一个类没有提供任何构造方法，系统会默认构造一个没有参数的构造方法（缺省构造器）</li>
<li>无参数构造方法和有参数构造方法都可以调用</li>
<li>无参数构造方法虽然没有代码但是默认在这里赋系统默认值</li>
<li>构造方法可以重载</li>
</ul>
<h2 id="二．封装">二．封装</h2>
<h3 id="1．封装的作用">1．封装的作用</h3>
<ol>
<li>保证内部结构的安全</li>
<li>屏蔽复杂，暴露简单</li>
</ol>
<h3 id="2．怎么进行封装">2．怎么进行封装</h3>
<ol>
<li>属性私有化（private）
<ul>
<li>Private表示私有的，被这个关键字修饰之后，该数据只能在本类中访问，出类不能访问。</li>
</ul>
</li>
<li>对外提供简单的操作入口
<ol>
<li>带有static的方法</li>
<li>不带有static的方法，用new对象引用去访问</li>
</ol>
<ul>
<li>称为实例方法，对象级别的方法（对象被称为实例，实例相关的都需要new对象，和引用来访问）</li>
</ul>
</li>
<li>空指针异常导致的最本质的原因是？
<ol>
<li>空引用访问实例相关的数据，会导致空指针异常</li>
<li>实例相关的包括，实例变量+实例方法</li>
</ol>
</li>
<li>对外提供公开的get方法和set方法作为操作入口，并且都不带static</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] 返回值类型 方法名 (形式参数列表)&#123;&#125;</span><br><span class="line"><span class="comment">/*get方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">(无参)</span></span>&#123;<span class="comment">//get属性名首字母大写</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*set方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span> <span class="params">(<span class="keyword">int</span> a（一个参数）)</span></span>&#123;</span><br><span class="line">    A = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5．封装代码实现两步</p>
<ul>
<li>属性私有化  一个属性提供get和set方法</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java构造方法</tag>
        <tag>Java封装</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记（四）面向对象</title>
    <url>/post/29980.html</url>
    <content><![CDATA[<h2 id="一、面向对象和面向过程的区别">一、面向对象和面向过程的区别</h2>
<ul>
<li>C 完全面向过程</li>
<li>C++ 一半面向过程一半面向对象</li>
<li>Java 完全面向对象</li>
</ul>
<h3 id="1-什么是面向过程的开发方式">1.什么是面向过程的开发方式</h3>
<ol>
<li>特点
<ol>
<li>注重步骤</li>
<li>注重因果关系</li>
</ol>
</li>
</ol>
<ul>
<li>缺点
<ul>
<li>代码和代码之间耦合度太高，扩展力太差</li>
</ul>
</li>
<li>优点
<ul>
<li>小型项目，采用面向过程方式进行开发，效率高</li>
</ul>
</li>
</ul>
<h3 id="2-什么是面向对象的开发方式">2.什么是面向对象的开发方式</h3>
<ol>
<li>将现实世界分隔成几个小的单元，然后每一个单元都实现成对象，然后驱动一下，让各个对象之间协作起来形成一个系统</li>
<li>特点<br>
耦合度低，扩展力强</li>
</ol>
<h3 id="3-采用面向对象的方式贯穿整个系统，涉及三个术语">3.采用面向对象的方式贯穿整个系统，涉及三个术语</h3>
<ul>
<li>OOA：面向对象分析</li>
<li>OOD：面向对象设计</li>
<li>OOP：面向对象编程</li>
</ul>
<p>分析-&gt;设计-&gt;编程</p>
<h3 id="4-面向对象包括三大特征">4.面向对象包括三大特征</h3>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h3 id="5-类和对象的概念">5.类和对象的概念</h3>
<ol>
<li>什么是类<br>
一种模板，描述所有对象的共同特征信息</li>
<li>什么是对象<br>
实际存在的个体</li>
</ol>
<p>Java语言中，要想得到对象，必须先定义一个类，对象是通过类这个模板创造出来的</p>
<p>术语</p>
<p>类 对象 实例 实例化 抽象</p>
<h2 id="二、类的定义">二、类的定义</h2>
<h3 id="1．定义">1．定义</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[修饰符列表] <span class="class"><span class="keyword">class</span> 类名</span>&#123;&#125; 类体=属性加方法</span><br><span class="line">属性在代码上以变量的形式存在</span><br><span class="line">属性以数据的形式存在（成员变量）</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xueSheng</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> xueHao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>java中所有的类都属于引用数据类型</p>
<h3 id="2．对象的创建和使用">2．对象的创建和使用</h3>
<ol>
<li>new 类名 ()</li>
<li>new是个运算符专门负责对象的创建
<ul>
<li><code>xueSheng s = new xueSheng ();</code></li>
</ul>
</li>
<li>关于编译的过程，对于编译器来说先编译test.java会自动找xuesheng.class，如果没有会自动编译xuesheng.java生成.class 文件</li>
</ol>
<h3 id="3．成员变量">3．成员变量</h3>
<p>没有手动赋值，系统默认赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> <span class="number">0</span>    <span class="keyword">short</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">0</span>      <span class="keyword">long</span> <span class="number">0L</span>  </span><br><span class="line"><span class="keyword">float</span> <span class="number">0.0F</span>    <span class="keyword">double</span> <span class="number">0.0</span>  </span><br><span class="line"><span class="keyword">boolean</span> <span class="keyword">false</span>   <span class="keyword">char</span> \u0000 引用数据类型 <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<h3 id="4．实例变量">4．实例变量</h3>
<ol>
<li>对象级别的变量</li>
<li>不能通过类名来直接访问实例变量</li>
</ol>
<p>对象和引用的区别</p>
<ol>
<li>对象是通过new出来的，在堆内存中储存</li>
<li>引用但凡是变量，并且该变量中保存了内存地址指向了堆内存中的对象</li>
<li>怎么访问实例变量：引用.实例变量名</li>
<li>通过=赋值将堆内存中实例变量的值进行修改</li>
</ol>
<h2 id="三、空指针异常">三、空指针异常</h2>
<ul>
<li>该对象没有引用指向它了，Java中规定程序员无法直接操作堆内存，只能等待gc把垃圾对象回收走。</li>
</ul>
<h2 id="四、方法调用时参数的传递问题">四、方法调用时参数的传递问题</h2>
<ul>
<li>Java中规定：参数传递的时候，和类型无关，不管你是基本数据类型，还是引用数据类型</li>
</ul>
]]></content>
      <categories>
        <category>JavaSE基础</category>
      </categories>
      <tags>
        <tag>JavaSE学习笔记</tag>
        <tag>Java面向对象</tag>
        <tag>Java类机制</tag>
        <tag>成员变量</tag>
        <tag>实例变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶学习笔记（一）IDEA工具的使用</title>
    <url>/post/56893.html</url>
    <content><![CDATA[<h2 id="IDEA工具的快捷键及设置">IDEA工具的快捷键及设置</h2>
<ol>
<li>字体设置<br>
file-&gt;settings-&gt;输入font-&gt;设置字体样式及字号大小</li>
<li>快速生成main()方法
<ul>
<li>psvm</li>
</ul>
</li>
<li>快速生成System.out.println()
<ul>
<li>sout</li>
</ul>
</li>
<li>IDEA自动保存</li>
<li>删除一行
<ul>
<li>ctrl+y</li>
</ul>
</li>
<li>运行——
<ul>
<li>右键+run</li>
<li>ctrl+shift+F10</li>
</ul>
</li>
<li>退出窗口
<ul>
<li>esc</li>
</ul>
</li>
<li>新增/新建/添加
<ul>
<li>alt+insert</li>
</ul>
</li>
<li>窗口变大变小
<ul>
<li>ctrl+shift+F12</li>
</ul>
</li>
<li>切换Java程序窗口
<ul>
<li>alt+右箭头/左箭头</li>
</ul>
</li>
<li>切换窗口
<ul>
<li>alt+快捷键</li>
</ul>
</li>
<li>提示方法的参数
<ul>
<li>ctrl+p</li>
</ul>
</li>
<li>注释
<ul>
<li>单行注释ctrl+/</li>
<li>多行注释ctrl+shift+/</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
        <tag>IDEA工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶学习笔记（三）抽象类</title>
    <url>/post/37418.html</url>
    <content><![CDATA[<h2 id="抽象类">抽象类</h2>
<ol>
<li>
<p>什么是抽象类？</p>
<ul>
<li>类和类之间具有共同特征，将这些共同特征提取出来，形成的就是抽象类</li>
<li>类到对象是实例化，对象到类是抽象</li>
<li>抽象类无法实例化，无法创建对象</li>
</ul>
</li>
<li>
<p>抽象类属于什么类型？</p>
<ul>
<li>抽象类也属于引用数据类型</li>
</ul>
</li>
<li>
<p>抽象类怎么定义？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表]<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    类体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>抽象类是用来被子类集成的</p>
<ul>
<li>子类继承抽象类，子类可以实例化</li>
</ul>
</li>
<li>
<p>final和abstract不能联合使用，这两个关键字是对立的</p>
</li>
<li>
<p>抽象类的子类可以是抽象类</p>
</li>
<li>
<p>抽象类但是抽象类有构造方法，构造方法供子类使用</p>
</li>
<li>
<p>抽象类关联到一个概念，抽象方法</p>
<ol>
<li>抽象方法表示没有实现的方法，没有方法体的方法</li>
<li><code>public abstract void dosome();</code></li>
<li>没有方法体，以分号结尾</li>
<li>前面修饰符列表中有abstract关键字</li>
</ol>
</li>
<li>
<p>抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中</p>
</li>
<li>
<p><strong>一个非抽象的类继承抽象类，必须将抽象类中的方法覆盖/重写/实现</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶学习笔记（二）final关键字</title>
    <url>/post/8933.html</url>
    <content><![CDATA[<h2 id="final关键字">final关键字</h2>
<ol>
<li>final是Java语言中的一个关键字</li>
<li>表示最终的不可变的</li>
<li>final修饰的变量
<ul>
<li>只能赋值一次</li>
</ul>
</li>
<li>final修饰的方法
<ul>
<li>无法被覆盖，被重写</li>
</ul>
</li>
<li>final修饰的类
<ul>
<li>无法继承</li>
</ul>
</li>
<li>final控制不了能不能调用</li>
</ol>
<h3 id="final修饰的引用">final修饰的引用</h3>
<ol>
<li>final修饰的引用只能指向一个对象，并且它只能永远指向该对象</li>
<li>并且该方法执行过程中，该引用指向对象后，该对象不会被垃圾回收器回收，知道当前方法结束，才会释放空间</li>
<li>虽然final的引用指向对象A后，不能再重新向B,但是对象A内部的数据可以被修改</li>
</ol>
<h3 id="final修饰的实例变量">final修饰的实例变量</h3>
<ol>
<li>final修饰的实例变量，系统不管赋默认值，要求程序员必须手动赋值</li>
<li>赶在系统赋默认值之前即可</li>
<li>一般添加static修饰为静态常量（常量名建议大写单词之间_连接）</li>
<li>常量和静态变量，都是存储在方法区，并且都是在类加载的时候初始化</li>
<li>常量一般都是公开的</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
        <tag>final关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶学习笔记（八）package和import</title>
    <url>/post/20061.html</url>
    <content><![CDATA[<h2 id="package和import">package和import</h2>
<p>包机制<br>
为了方便程序管理，不同功能的类，分别存放在不同的包下</p>
<h3 id="package">package</h3>
<p>包（package）</p>
<ul>
<li>把功能相似或相关的类组织在同一个包中</li>
<li>包也采用了树形目录的存储方式</li>
<li>通过包也可限定类的访问权限</li>
<li>包的命名规范
<ul>
<li>包采用“逆域名法”进行命名，用”.”分割，单词全部小写</li>
<li>标准格式 域名后缀.组织机构名.项目名[.模块名].包的职能</li>
<li>类中需要声明隶属于的包</li>
</ul>
</li>
</ul>
<ol>
<li>package出现在Java源文件第一行</li>
<li>带有包名的编译
<ul>
<li>javac -d . xxx.java</li>
</ul>
</li>
<li>运行 Java完整类名</li>
</ol>
<h3 id="import">import</h3>
<p>Import关键词用于导入其他包的类</p>
<ol>
<li>import什么时候不需要
<ul>
<li>java.lang不需要</li>
<li>同包不需要</li>
<li>其他都需要</li>
</ul>
</li>
<li>语法
<ul>
<li><code>import 完整类名</code></li>
<li><code>import 包名.*</code></li>
<li>import只能出现在package语句之下，class声明语句之上</li>
</ul>
</li>
</ol>
<h3 id="访问控制权限修饰符">访问控制权限修饰符</h3>
<p>访问修饰符用于控制类、成员变量、方法的访问范围</p>
<ul>
<li>Private 私有 只能在类的内部访问</li>
<li>Public 公共 在任何地方都能访问</li>
<li>(default) 默认 相同包的其他类可以访问</li>
<li>Protected 继承 只有继承的子类能访问到</li>
</ul>
<ol>
<li>访问控制权限可以修饰什么？
<ul>
<li>4个属性</li>
<li>4个方法</li>
<li>类（public和默认）</li>
<li>接口（public和默认）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>package和import</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶学习笔记（五）源码及API文档概述</title>
    <url>/post/6399.html</url>
    <content><![CDATA[<h2 id="Object类">Object类</h2>
<h3 id="Java源码及API文档概述">Java源码及API文档概述</h3>
<ol>
<li>如何获取方法
<ul>
<li>去源代码当中查看</li>
<li>去查阅Java类库的帮助文档</li>
</ul>
</li>
<li>API（Application Program Interface）
<ul>
<li>应用程序编程接口</li>
<li>整个JDK类库就是一个JavaSE的API</li>
<li>每一个API都会配置一套API帮助文档</li>
</ul>
</li>
</ol>
<h3 id="Object类的几个方法">Object类的几个方法</h3>
<ul>
<li><code>protected Object clone();//负责对象克隆</code></li>
<li><code>int hashCode();//获取对象哈希值</code></li>
<li><code>boolean equals(Object obj1);//判断两个对象是否相等</code></li>
<li><code>String toString();//将对象转换成字符串形式</code></li>
<li><code>protected void finalize();//垃圾回收负责调用的方法</code></li>
</ul>
<h3 id="Object中的toString-方法">Object中的toString()方法</h3>
<ol>
<li>
<p>toString()方法源码</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getClass().getName() + <span class="string">&quot;0&quot;</span> + Integer.toHexString(hashCodde());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源代码上toString()方法的默认实现是：</p>
<ul>
<li>类名@对象的内存地址转换为十六进制的形式</li>
</ul>
</li>
<li>
<p>toString()方法的作用</p>
<ul>
<li>通过调用这个方法可以将一个Java对象转换成字符串形式</li>
</ul>
</li>
<li>
<p>建议所有子类都重写toString()方法，越简洁越好，可读性越强越好</p>
</li>
</ol>
<h3 id="Object的equals-方法">Object的equals()方法</h3>
<ol>
<li>
<p>equals()方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="keyword">this</span>==obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>equals()方法作用是判断两个对象是否相等</p>
</li>
<li>
<p>判断两个Java对象是否相等不能用&quot;==“，”==&quot;判断的是两个Java对象的内存地址是否相等，需要重写equals()方法</p>
</li>
<li>
<p>如何重写equals()方法</p>
<ul>
<li>相同的返回值类型、相同的方法名、相同的形式参数列表</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果为空直接false</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果不是类A直接false</span></span><br><span class="line">    <span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> A))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果地址相等直接false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//转型开始比较各项的值</span></span><br><span class="line">    A a = (A)obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.m==a.m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> A)&#123;</span><br><span class="line">    <span class="keyword">this</span>.B = A.B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IDEA工具可以快捷重写方法</p>
</li>
</ol>
<h3 id="String类的toString-方法和equals-方法">String类的toString()方法和equals()方法</h3>
<ol>
<li>toString()方法，已经重写</li>
<li>equals()方法，比较两个字符串不能用==，必须使用equals()方法</li>
</ol>
<p>注意：</p>
<ul>
<li>== 基本数据类型比较是否相等</li>
<li>equals() 所有引用数据类型</li>
<li>输出引用的时候会自动调用toString()方法，并输出十六进制地址</li>
</ul>
<h3 id="Object类的finalize-方法">Object类的finalize()方法</h3>
<ol>
<li>
<p>finalize()方法的源码</p>
<p><code>protected void finalize() throws Throwable&#123;&#125;</code></p>
</li>
<li>
<p>finalize()方法只有一个方法体，里面没有代码，而且这个方法是protected修饰的</p>
</li>
<li>
<p>这个方法不需要程序员手动调用，JVM的垃圾回收器负责调用这个方法</p>
</li>
<li>
<p>finalize()方法的执行时</p>
<ul>
<li>当一个Java对象即将被垃圾回收的时候，垃圾回收器负责调用finalize()方法</li>
</ul>
</li>
<li>
<p>finalize()方法实际上是SUN公司为Java程序员准备的垃圾销毁时机，如果希望在对象销毁时机执行一段代码的话，这段代码要写到finalize()方法当中</p>
</li>
<li>
<p>静态代码块的作用</p>
<ul>
<li>static{}</li>
<li>静态代码块在类加载时执行，并且只执行一次</li>
<li>finalize()</li>
<li>不需要调用直接重写即可，是垃圾回收时执行</li>
</ul>
</li>
<li>
<p>例如：项目需要对象在JVM中被释放的时候记录时间，就可以用finalize()</p>
</li>
</ol>
<h3 id="Object类的hashCode-方法">Object类的hashCode()方法</h3>
<ol>
<li>hashCode()方法
<ul>
<li><code>public native int hashCode();</code></li>
<li>这个方法不是抽象方法，带有native关键字，底层调用C++程序</li>
</ul>
</li>
<li>hashCode()方法返回哈希码
<ul>
<li>实际上就是一个Java对象的内存地址，经过哈希算法，得出的一个值，可以等同看做Java对象的内存地址</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
        <tag>Java源码API文档</tag>
        <tag>Object类</tag>
        <tag>toString()方法</tag>
        <tag>equals()方法</tag>
        <tag>finalize()方法</tag>
        <tag>hashCode()方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶学习笔记（四）接口</title>
    <url>/post/61624.html</url>
    <content><![CDATA[<h2 id="接口">接口</h2>
<h3 id="接口的基础语法">接口的基础语法</h3>
<ol>
<li>
<p>接口也是一种引用数据类型，编译后也是class文件</p>
</li>
<li>
<p>接口是完全抽象</p>
</li>
<li>
<p>接口怎么定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符列表] <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口支持多继承</p>
</li>
<li>
<p>接口中只含有两部分，一部分常量，另一部分抽象方法</p>
</li>
<li>
<p>接口中的抽象方法可以省略<code>public abstract</code></p>
</li>
<li>
<p>接口中的方法都是抽象方法不可以有方法体</p>
</li>
<li>
<p>接口中的常量可以省略<code>public static final</code></p>
</li>
<li>
<p>继承使用<code>extends</code>，实现使用<code>implements</code></p>
</li>
<li>
<p><strong>当一个非抽象的类实现接口的话，必须将接口中所有的抽象方法实现</strong></p>
</li>
<li>
<p>一个类可以实现多个接口，类似于多继承</p>
</li>
<li>
<p>接口和接口之间进行强制类型转换的时候，没有继承关系也可以强转，但是一定要注意，运行时可能会出现<code>ClassCastException</code>异常，编译没问题，运行有问</p>
</li>
<li>
<p>extends在前implements在后</p>
</li>
<li>
<p>接口通常提取行为动作</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>Java学习笔记</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合框架</title>
    <url>/post/40254.html</url>
    <content><![CDATA[<h2 id="Java-集合框架概述">Java 集合框架概述</h2>
<p>Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p>
<ol>
<li>所有集合类都位于java.util包下。</li>
<li>Java的集合类主要由两个接口派生而出：Collection和Map</li>
<li>集合接口：6个接口，表示不同集合类型，是集合框架的基础。
<ul>
<li>Collection、Map、List、Set、Queue、Iterator、LinkIterator</li>
</ul>
</li>
<li>抽象类：5个抽象类，对集合接口的部分实现。可扩展为自定义集合类。
<ul>
<li>AbstractMap、AbstractCollection、AbstractList、AbstractSet、AbstractSequenttialList</li>
</ul>
</li>
<li>实现类：对接口的具体实现。
<ul>
<li>ArrayList、LinkedList、Vector、Stack、HashSet、LinkedHashSet、TreeSet、HashMap、TreeMap</li>
</ul>
</li>
</ol>
<h2 id="Collection">Collection</h2>
<ol>
<li>Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。是一组允许重复的对象。</li>
<li>另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。我们通过Iterator迭代器来遍历集合。
<ul>
<li>ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。</li>
</ul>
</li>
<li>Set 接口继承 Collection，集合元素不重复。
<ul>
<li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问。</li>
<li>Set的实现类有HastSet和TreeSet。
<ul>
<li>HashSet依赖于HashMap，它实际上是通过HashMap实现的；</li>
<li>TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</li>
</ul>
</li>
</ul>
</li>
<li>List 接口继承 Collection，允许重复，维护元素插入顺序。
<ul>
<li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。</li>
<li>List的实现类有LinkedList, ArrayList, Vector, Stack。</li>
</ul>
</li>
</ol>
<h3 id="ArrayList">ArrayList</h3>
<ul>
<li>ArrayList是动态数组。</li>
<li>它允许任何符合规则的元素插入甚至包括null。</li>
<li>每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。</li>
<li>随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</li>
<li>ArrayList擅长于随机访问。同时ArrayList是非同步的。</li>
</ul>
<h3 id="LinkedList">LinkedList</h3>
<ul>
<li>LinkedList是双向链表。</li>
<li>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</li>
<li>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</li>
<li><code>List list = Collections.synchronizedList(new LinkedList(...));</code></li>
</ul>
<h3 id="ArrayList和LinkedList">ArrayList和LinkedList</h3>
<ol>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。</li>
<li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li>
<li>这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</li>
</ol>
<h3 id="Vector">Vector</h3>
<ul>
<li>Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</li>
</ul>
<h3 id="Stack">Stack</h3>
<ul>
<li>Stack继承自Vector，实现一个后进先出的堆栈。</li>
<li>Stack刚创建后是空栈。</li>
</ul>
<h3 id="HashSet">HashSet</h3>
<ul>
<li>HashSet是没有重复元素的集合。</li>
<li>它是由HashMap实现的，不保证元素的顺序。</li>
<li>HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。</li>
<li>HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。</li>
<li>HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。</li>
<li>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</li>
</ul>
<h3 id="LinkedHashSet">LinkedHashSet</h3>
<ul>
<li>LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。</li>
<li>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序。</li>
<li>当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</li>
</ul>
<h3 id="TreeSet">TreeSet</h3>
<ul>
<li>TreeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。</li>
<li>TreeSet可以确保集合元素处于排序状态。</li>
<li>TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</li>
<li>当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；</li>
<li>若用户需要使用自定义的比较器，则需要使用带比较器的参数。</li>
</ul>
<p>注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p>
<h3 id="HashSet、LinkedHashSet、TreeSet比较">HashSet、LinkedHashSet、TreeSet比较</h3>
<ol>
<li>
<p>Set接口</p>
<ul>
<li>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</li>
<li>Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</li>
</ul>
</li>
<li>
<p>HashSet</p>
<ul>
<li>不能保证元素的排列顺序，顺序有可能发生变化。</li>
<li>不是同步的。</li>
<li>集合元素可以是null，但只能放入一个null。</li>
<li>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。</li>
<li>注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</li>
</ul>
</li>
<li>
<p>LinkedHashSet</p>
<ul>
<li>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的</li>
<li>当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</li>
<li>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</li>
</ul>
</li>
<li>
<p>TreeSet类</p>
<ul>
<li>TreeSet是SortedSet接口的唯一实现类</li>
<li>TreeSet可以确保集合元素处于排序状态。</li>
<li>TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。</li>
<li>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。</li>
<li>自然排序
<ul>
<li>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。
<ul>
<li>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0</li>
</ul>
</li>
</ul>
</li>
<li>定制排序
<ul>
<li>自然排序是根据集合元素的大小，以升序排列，</li>
<li>如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="Map">Map</h2>
<ol>
<li>Map接口是键－值对象，与Collection接口没有什么关系。
<ul>
<li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</li>
</ul>
</li>
<li>AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。</li>
</ol>
<h3 id="HashMap">HashMap</h3>
<ul>
<li>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置。</li>
<li>其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，</li>
<li>如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</li>
</ul>
<h3 id="HashTable与HashMap">HashTable与HashMap</h3>
<ol>
<li>
<p>相同点：</p>
<ul>
<li>都实现了Map、Cloneable、java.io.Serializable接口。</li>
<li>都是存储&quot;键值对(key-value)&quot;的散列表，而且都是采用拉链法实现的。</li>
</ul>
</li>
<li>
<p>不同点：</p>
<ul>
<li>历史原因:HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</li>
<li>同步性:HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</li>
<li>对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。</li>
<li>基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。</li>
<li>支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</li>
</ul>
</li>
</ol>
<ul>
<li>Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。 然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。</li>
<li>AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。</li>
</ul>
<h3 id="LinkedHashMap">LinkedHashMap</h3>
<ul>
<li>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</li>
<li>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。</li>
<li>此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</li>
<li>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</li>
<li>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。</li>
<li>默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</li>
<li>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</li>
<li>由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</li>
</ul>
<h3 id="TreeMap">TreeMap</h3>
<ul>
<li>TreeMap是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。</li>
<li>TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。
<ul>
<li>自然排序：
<ul>
<li>TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</li>
</ul>
</li>
<li>定制排序：
<ul>
<li>定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</li>
</ul>
</li>
<li>TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。</li>
</ul>
</li>
<li>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。</li>
</ul>
<h3 id="HashMap、Hashtable、LinkedHashMap和TreeMap比较">HashMap、Hashtable、LinkedHashMap和TreeMap比较</h3>
<ol>
<li>Hashmap 是一个最常用的Map
<ul>
<li>它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。</li>
<li>遍历时，取得数据的顺序是完全随机的。</li>
<li>HashMap最多只允许一条记录的键为Null;</li>
<li>允许多条记录的值为Null;</li>
<li>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。</li>
<li>如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</li>
</ul>
</li>
<li>Hashtable 与 HashMap类似
<ul>
<li>它不允许记录的键或者值为空;</li>
<li>它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。</li>
</ul>
</li>
<li>LinkedHashMap保存了记录的插入顺序，
<ul>
<li>在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。</li>
<li>在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</li>
<li>如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用</li>
<li>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。</li>
</ul>
</li>
<li>TreeMap实现SortMap接口，内部实现是红黑树。
<ul>
<li>能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，</li>
<li>当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</li>
</ul>
</li>
</ol>
<ul>
<li>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，</li>
<li>它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。</li>
<li>在Map 中插入、删除和定位元素，HashMap 是最好的选择。</li>
<li>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</li>
<li>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。</li>
</ul>
<h3 id="迭代器">迭代器</h3>
<ol>
<li>Iterator。它是迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。
<ul>
<li>ListIterator是专门为遍历List而存在的。</li>
</ul>
</li>
<li>Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。
<ul>
<li>Enumeration只能在Hashtable, Vector, Stack中使用。</li>
</ul>
</li>
</ol>
<h4 id="Iterator">Iterator</h4>
<ul>
<li>Iterator是一个接口，它是集合的迭代器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span>：判断集合里是否存在下一个元素。如果有，<span class="title">hasNext</span><span class="params">()</span>方法返回 <span class="keyword">true</span>。</span></span><br><span class="line"><span class="function">Object <span class="title">next</span><span class="params">()</span>：返回集合里下一个元素。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span>：删除集合里上一次next方法返回的元素。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Iterator只能单向移动。</li>
<li>Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；</li>
<li>如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。</li>
<li>而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常。</li>
</ul>
<h4 id="ListIterator">ListIterator</h4>
<ul>
<li>ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口,只能用于各种List类型的访问。</li>
<li>可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>双向移动（向前/向后遍历）</li>
<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引</li>
<li>可以使用set()方法替换它访问过的最后一个元素</li>
<li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.</li>
</ul>
<h4 id="Iterator和ListIterator区别">Iterator和ListIterator区别</h4>
<ul>
<li>List和Set都有iterator()来取得其迭代器。</li>
<li>对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的
<ul>
<li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能</li>
<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。</li>
<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li>
<li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
<li>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</li>
</ul>
</li>
</ul>
<h3 id="工具类">工具类</h3>
<ol>
<li>Arrays和Collections。它们是操作数组、集合的两个工具类。</li>
</ol>
<h4 id="Collection-和-Collections区别">Collection 和 Collections区别</h4>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。
<ul>
<li>它提供了对集合对象进行基本操作的通用接口方法。</li>
<li>Collection接口在Java 类库中有很多具体的实现。</li>
<li>Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
</ul>
</li>
<li>java.util.Collections 是一个包装类（工具类/帮助类）。
<ul>
<li>它包含有各种有关集合操作的静态多态方法。</li>
<li>此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java集合框架</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Java集合框架</tag>
      </tags>
  </entry>
</search>
